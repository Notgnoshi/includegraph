#!/usr/bin/env python3
"""Filter a TGF graph generated by includegraph.py.

There are two kinds of rules you can use to query the dependency graph.
1. (--filter) You can filter out specific subtrees that match a given glob
2. (--keep-only) You can filter out everything _except_ subtrees that match a given glob

These two options can be given multiple times. If both --keep-only and --filter globs are given, the
--filter globs are applied after the --keep-only globs.
"""
import argparse
import collections
import functools
import itertools
import logging
import sys
from pathlib import Path, PurePath
from typing import Dict, Iterable, Set, Tuple

# This is kind of hacky, but there's two other options:
# 1. duplicate the shared stuff and hope they stay in sync
# 2. add an includegraph library, and require it gets installed in order to use the scripts
# I don't like the first option because it's a maintenance nightmare, but I also don't like the
# second option because it increases the friction to use these tools.
repo_root = Path(__file__).resolve().parent
repo_root = str(repo_root)
sys.path.insert(0, repo_root)
try:
    from includegraph import output_dep_graph_tgf
    from tgf2graphviz import IncludeGraph, parse_tgf_graph
except ImportError:
    logging.critical("Failed to import types from includegraph.py.")
    raise

LOG_LEVELS = {
    "CRITICAL": logging.CRITICAL,
    "ERROR": logging.ERROR,
    "WARNING": logging.WARNING,
    "INFO": logging.INFO,
    "DEBUG": logging.DEBUG,
}
DEFAULT_LEVEL = "INFO"


def parse_args():
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "--input",
        "-i",
        type=argparse.FileType("r"),
        default=sys.stdin,
        help="The path to the input graph. Defaults to stdin.",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=argparse.FileType("w"),
        default=sys.stdout,
        help="The file to save the output to. Defaults to stdout.",
    )
    parser.add_argument(
        "--log-level",
        "-l",
        type=str,
        default=DEFAULT_LEVEL,
        choices=LOG_LEVELS.keys(),
        help=f"Set the logging output level. Defaults to {DEFAULT_LEVEL}.",
    )
    parser.add_argument(
        "--shorten-file-paths",
        "-s",
        action="store_true",
        default=False,
        help="Shorten absolute node file paths",
    )
    parser.add_argument(
        "--filter-transitive-system-headers",
        action="store_true",
        default=False,
        help="Remove system headers included by another system header.",
    )
    parser.add_argument(
        "--filter-system-headers",
        action="store_true",
        default=False,
        help="Remove all system headers from the graph.",
    )
    parser.add_argument(
        "--filter",
        "-f",
        type=str,
        action="append",
        help="Remove subtrees where the root nodes match the given filepath glob(s). Applied after any --keep globs, if any are present.",
    )
    parser.add_argument(
        "--keep-only",
        "-k",
        type=str,
        action="append",
        help="Keep only subtrees where the root node matches the given filepath glob(s)",
    )
    return parser.parse_args()


def map_basenames_to_absolute(paths: Iterable[str]) -> Dict[str, Set[str]]:
    """Map the file basenames to their absolute paths.

    Example input:
        /a/b/c.h
        /a/b/d.h
        /a/c/c.h

    Example output:
        c.h -> {/a/b/c.h, /a/c/c.h}
        d.h -> {/a/b/d.h, }

    A helper for shorten_absolute_paths.
    """
    mapping = collections.defaultdict(set)
    for path in paths:
        path = PurePath(path)
        mapping[path.name].add(str(path))

    return mapping


def all_equal(s: Iterable) -> bool:
    """Determine if every element of the given iterable are equal."""
    g = itertools.groupby(s)
    return next(g, True) and not next(g, False)


def shortest_unique_suffixes(paths: Set[str]) -> Dict[str, str]:
    """Find the shortest unique suffix for each of the given strings.

    Example input:
        {/a/b/c.h, /a/c/c.h}

    Example output:
        /a/b/c.h -> b/c.h
        /a/c/c.h -> c/c.h
    """
    paths = list(paths)  # need deterministic ordering, so no set for you.
    path_parts = (PurePath(p) for p in paths)
    path_parts = (reversed(p.parts) for p in path_parts)
    path_parts = zip(*path_parts)

    # Start at the end:
    # 0. (c.h, c.h)  # Equal, continue
    # 1. (b/, c/)    # Not equal, break
    # This results in:
    # [(c.h, c.h), (b/, c/)]
    suffixes = []
    for level in path_parts:
        # create the suffix for each path
        suffixes.append(level)
        if len(level) == 1 or not all_equal(level):
            break

    # Then we take
    # [(c.h, c.h), (b/, c/)]
    # and prepend the levels to generate
    # (b/c.h, c/c.h)
    def prepend_levels(level1: Tuple[str], level2: Tuple[str]) -> Tuple[str]:
        return tuple(PurePath(l2) / l1 for l1, l2 in zip(level1, level2))

    suffixes = functools.reduce(prepend_levels, suffixes)
    suffixes = (str(s) for s in suffixes)
    suffixes = dict(zip(paths, suffixes))
    return suffixes


def shorten_absolute_paths(paths: Iterable[str]) -> Dict[str, str]:
    """Shorten the given absolute paths into the shortest unique suffix.

    Example input:
        /a/b/c.h
        /a/b/d.h
        /a/c/c.h

    Example output:
        /a/b/c.h -> b/c.h
        /a/b/d.h -> d.h
        /a/c/c.h -> c/c.h

    That is, the returned dictionary maps the absolute paths to their shortened form.
    """
    suffixes = {}
    # Determine if there are multiple occurrences of the same header
    multiple_occurrences = map_basenames_to_absolute(paths)
    for basename, occurrences in multiple_occurrences.items():
        # Nominal case. There's no need to find the shortest suffix.
        if len(occurrences) == 1:
            absolute = occurrences.pop()
            suffix = basename
            suffixes[absolute] = suffix
        else:
            suffixes.update(shortest_unique_suffixes(occurrences))

    return suffixes


def main(args):
    graph: IncludeGraph = parse_tgf_graph(args.input)
    # TODO: Filter the graph
    if args.shorten_file_paths:
        logging.debug("Shortening absolute file paths...")
        paths = [node.filename for node in graph]
        shortened_filenames = shorten_absolute_paths(paths)
        for node in graph:
            shortened_filename = shortened_filenames.get(node.filename, node.filename)
            node.filename = shortened_filename

    output_dep_graph_tgf(graph, args.output)


if __name__ == "__main__":
    args = parse_args()
    logging.basicConfig(
        format="%(asctime)s - %(module)s - %(levelname)s - %(message)s",
        level=LOG_LEVELS.get(args.log_level),
        stream=sys.stderr,
    )
    main(args)
